"""
Integration tests: guard conditions in Phase 2 and sync-pair deletion/recreation.

Uses FakeCalendarClient + a real SQLite StateDatabase so that run_two_way()
executes end-to-end without an EDS daemon.

Guard-condition tests (TestGuardConditionsPhase2)
--------------------------------------------------
Each test seeds the work calendar with one event that should be filtered by a
guard in Phase 2 of run_two_way().  The personal calendar starts empty.  After
the sync the personal calendar must remain empty (no creates).  The guards
tested are:

    is_managed_event   – circular-loop prevention
    is_event_cancelled – Exchange rejects STATUS:CANCELLED creates
    is_free_time       – TRANSP:TRANSPARENT events must not block personal cal
    has_valid_occurrences – empty recurring series (all occurrences EXDATE-excluded)

Deletion/recreation tests (TestSyncPairDeletions)
-------------------------------------------------
Each test pre-seeds one state record in the DB (simulating a previously-synced
pair), manipulates the fake clients so that one or both events appear deleted,
then runs run_two_way() and asserts the expected outcome.
"""

from eds_calendar_sync.models import SyncStats
from eds_calendar_sync.sync.two_way import run_two_way
from tests.conftest import make_cancelled_vevent
from tests.conftest import make_managed_vevent
from tests.conftest import make_recurring_vevent
from tests.conftest import make_transparent_vevent
from tests.conftest import make_vevent
from tests.fake_client import FakeCalendarClient

# ---------------------------------------------------------------------------
# Shared run helper
# ---------------------------------------------------------------------------


def _run(config, logger, work_client, personal_client, state_db) -> SyncStats:
    stats = SyncStats()
    run_two_way(config, stats, logger, work_client, personal_client, state_db)
    return stats


# ---------------------------------------------------------------------------
# TestGuardConditionsPhase2
# ---------------------------------------------------------------------------


class TestGuardConditionsPhase2:
    """Phase 2 guard conditions must prevent syncing filtered work events."""

    def test_managed_work_event_not_synced(self, state_db, sync_config, sync_logger):
        """is_managed_event: managed work events must NOT be synced to personal."""
        work_client = FakeCalendarClient({"W_MGD": make_managed_vevent("W_MGD")})
        personal_client = FakeCalendarClient({})

        _run(sync_config, sync_logger, work_client, personal_client, state_db)

        assert len(personal_client.creates) == 0, (
            "Managed work event must not be mirrored to personal calendar"
        )
        assert personal_client.event_count == 0

    def test_cancelled_work_event_not_synced(self, state_db, sync_config, sync_logger):
        """is_event_cancelled: STATUS:CANCELLED work events must NOT be synced."""
        work_client = FakeCalendarClient({"W_CAN": make_cancelled_vevent("W_CAN")})
        personal_client = FakeCalendarClient({})

        _run(sync_config, sync_logger, work_client, personal_client, state_db)

        assert len(personal_client.creates) == 0, (
            "Cancelled work event must not be mirrored to personal calendar"
        )
        assert personal_client.event_count == 0

    def test_free_time_work_event_not_synced(self, state_db, sync_config, sync_logger):
        """is_free_time: TRANSP:TRANSPARENT work events must NOT be synced."""
        work_client = FakeCalendarClient({"W_TRP": make_transparent_vevent("W_TRP")})
        personal_client = FakeCalendarClient({})

        _run(sync_config, sync_logger, work_client, personal_client, state_db)

        assert len(personal_client.creates) == 0, (
            "Transparent (free-time) work event must not be mirrored to personal calendar"
        )
        assert personal_client.event_count == 0

    def test_empty_series_not_synced(self, state_db, sync_config, sync_logger):
        """has_valid_occurrences: recurring series with all occurrences excluded must NOT be synced.

        This guard prevents the Exchange ErrorItemNotFound error that occurs when
        the backend tries to create a series whose master EXDATE covers every
        occurrence generated by the RRULE.
        """
        # COUNT=2 → occurrences 20260301, 20260302; both EXDATE-excluded
        empty_series = make_recurring_vevent("W_EMP", count=2, exdates=("20260301", "20260302"))
        work_client = FakeCalendarClient({"W_EMP": empty_series})
        personal_client = FakeCalendarClient({})

        _run(sync_config, sync_logger, work_client, personal_client, state_db)

        assert len(personal_client.creates) == 0, (
            "Empty recurring series must not be mirrored to personal calendar"
        )
        assert personal_client.event_count == 0


# ---------------------------------------------------------------------------
# TestSyncPairDeletions
# ---------------------------------------------------------------------------


class TestSyncPairDeletions:
    """_process_sync_pair deletion and recreation branches.

    DB conventions used throughout:
      - source_uid  → work UID
      - target_uid  → personal UID
      - origin='source' → work was the authoritative source (work→personal)
      - origin='target' → personal was the authoritative source (personal→work)
    """

    # ------------------------------------------------------------------ helpers

    def _seed(self, state_db, work_uid, personal_uid, origin):
        """Insert a state record with placeholder hashes and commit."""
        state_db.insert_bidirectional(
            work_uid, personal_uid, "placeholder_src_hash", "placeholder_tgt_hash", origin
        )
        state_db.commit()

    # ------------------------------------------------------------------ tests

    def test_both_deleted_cleans_db(self, state_db, sync_config, sync_logger):
        """When both events are missing, the DB record is deleted and no ops are issued."""
        work_uid = "BOTH_W"
        personal_uid = "BOTH_P"
        self._seed(state_db, work_uid, personal_uid, "source")

        work_client = FakeCalendarClient({})
        personal_client = FakeCalendarClient({})

        stats = _run(sync_config, sync_logger, work_client, personal_client, state_db)

        # DB record cleaned up
        assert state_db.get_by_source_uid(work_uid) is None
        # No calendar operations
        assert len(work_client.creates) == 0
        assert len(work_client.removes) == 0
        assert len(personal_client.creates) == 0
        assert len(personal_client.removes) == 0
        assert stats.errors == 0

    def test_work_deleted_source_deletes_personal(self, state_db, sync_config, sync_logger):
        """Work authoritative (origin='source'), work deleted → personal mirror is removed."""
        work_uid = "W_DELETED_SRC"
        personal_uid = "P_MIRROR_SRC"
        self._seed(state_db, work_uid, personal_uid, "source")

        work_client = FakeCalendarClient({})  # work event gone
        personal_client = FakeCalendarClient({personal_uid: make_vevent(personal_uid)})

        stats = _run(sync_config, sync_logger, work_client, personal_client, state_db)

        assert personal_uid in personal_client.removes, (
            "Personal mirror must be removed when its authoritative work event is deleted"
        )
        assert state_db.get_by_source_uid(work_uid) is None
        assert stats.deleted == 1
        assert stats.errors == 0

    def test_work_deleted_target_recreates_work(self, state_db, sync_config, sync_logger):
        """Personal authoritative (origin='target'), work mirror deleted → work is recreated."""
        old_work_uid = "W_OLD_TGT"
        personal_uid = "P_SOURCE_TGT"
        self._seed(state_db, old_work_uid, personal_uid, "target")

        work_client = FakeCalendarClient({})  # work mirror deleted externally
        personal_client = FakeCalendarClient({personal_uid: make_vevent(personal_uid)})

        stats = _run(sync_config, sync_logger, work_client, personal_client, state_db)

        # A new work event should have been created (busy block from personal)
        assert len(work_client.creates) == 1, (
            "A new work event must be recreated when the personal event is authoritative"
        )
        assert stats.added == 1
        assert stats.errors == 0

        # Old state record is gone; a new one with the fresh work UID must exist
        assert state_db.get_by_source_uid(old_work_uid) is None
        new_work_uid = work_client.creates[0]
        new_record = state_db.get_by_source_uid(new_work_uid)
        assert new_record is not None
        assert new_record["target_uid"] == personal_uid

    def test_personal_deleted_target_deletes_work(self, state_db, sync_config, sync_logger):
        """Personal authoritative (origin='target'), personal deleted → work mirror is removed."""
        work_uid = "W_MIRROR_TGT"
        personal_uid = "P_DELETED_TGT"
        self._seed(state_db, work_uid, personal_uid, "target")

        work_client = FakeCalendarClient({work_uid: make_vevent(work_uid)})
        personal_client = FakeCalendarClient({})  # personal event gone

        stats = _run(sync_config, sync_logger, work_client, personal_client, state_db)

        assert work_uid in work_client.removes, (
            "Work mirror must be removed when its authoritative personal event is deleted"
        )
        assert state_db.get_by_source_uid(work_uid) is None
        assert stats.deleted == 1
        assert stats.errors == 0

    def test_personal_deleted_source_recreates_personal(self, state_db, sync_config, sync_logger):
        """Work authoritative (origin='source'), personal mirror deleted → personal recreated."""
        work_uid = "W_SOURCE_SRC"
        old_personal_uid = "P_OLD_SRC"
        self._seed(state_db, work_uid, old_personal_uid, "source")

        work_client = FakeCalendarClient({work_uid: make_vevent(work_uid)})
        personal_client = FakeCalendarClient({})  # personal mirror deleted externally

        stats = _run(sync_config, sync_logger, work_client, personal_client, state_db)

        # A new personal event should have been created
        assert len(personal_client.creates) == 1, (
            "A new personal event must be recreated when the work event is authoritative"
        )
        assert stats.added == 1
        assert stats.errors == 0

        # New DB record links the same work_uid to the freshly-created personal UID
        new_record = state_db.get_by_source_uid(work_uid)
        assert new_record is not None
        new_personal_uid = personal_client.creates[0]
        assert new_record["target_uid"] == new_personal_uid
